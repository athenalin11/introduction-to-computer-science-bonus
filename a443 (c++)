#include <cstdio>
#include <algorithm>
#include <functional>
using namespace std;

const int MAXN = 1000005;
int deg[MAXN];

bool canConstruct(int n) {
    // 基本檢查
    long long sum = 0;
    for (int i = 0; i < n; i++) {
        if (deg[i] < 0 || deg[i] >= n) return false;
        sum += deg[i];
    }
    if (sum % 2 != 0) return false;
    
    // 排序
    sort(deg, deg + n, greater<int>());
    
    // Erdős–Gallai theorem with O(n log n) optimization
    long long left_sum = 0;
    
    // 預計算後綴和
    long long suffix[MAXN];
    suffix[n] = 0;
    for (int i = n - 1; i >= 0; i--) {
        suffix[i] = suffix[i + 1] + deg[i];
    }
    
    for (int k = 1; k <= n; k++) {
        left_sum += deg[k-1];
        
        // 二分搜尋第一個 deg[i] <= k 的位置
        int left = k, right = n + 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (mid < n && deg[mid] > k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        int pos = left;
        
        // [k, pos) 的 deg[i] > k，貢獻 k
        // [pos, n) 的 deg[i] <= k，貢獻 deg[i]
        long long right_sum_min = (long long)(pos - k) * k + suffix[pos];
        long long right_sum = (long long)k * (k - 1) + right_sum_min;
        
        if (left_sum > right_sum) return false;
    }
    
    return true;
}

int main() {
    int n;
    while (scanf("%d", &n) == 1 && n != 0) {
        for (int i = 0; i < n; i++) {
            scanf("%d", &deg[i]);
        }
        
        if (canConstruct(n)) {
            printf("Possible\n");
        } else {
            printf("Not possible\n");
        }
    }
    
    return 0;
}
